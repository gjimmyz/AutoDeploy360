- name: Include vars
  include_vars: ../vars/ssh_relate.yaml

- name: Check required dependencies and files
  block:
    - name: Check if ansible.netcommon is installed
      shell: ansible-galaxy collection list | grep 'ansible.netcommon'
      register: netcommon_check
      ignore_errors: true
      changed_when: false

    - name: Prompt user to install ansible.netcommon if not installed
      fail:
        msg: "The Ansible 'ansible.netcommon' collection is required. Please install it."
      when: netcommon_check.stdout == ""

    - name: Check if fping is installed on remote host
      command: which fping
      register: fping_check
      ignore_errors: true
      changed_when: false
      delegate_to: "{{ ssh_host }}"

    - name: Prompt user to install fping on remote host if not installed
      fail:
        msg: "'fping' is not installed on remote host. Please install it."
      when: fping_check.rc != 0

    - name: Check if pid_ip_file_path exists
      stat:
        path: "{{ pid_ip_file_path }}"
      register: ip_file_stat

    - name: If pid_ip_file_path exists, read its content
      slurp:
        src: "{{ pid_ip_file_path }}"
      register: previous_reachable_ips_file
      when: ip_file_stat.stat.exists

    - name: Extract previously reachable IPs if file was found
      set_fact:
        previous_reachable_ips: "{{ (previous_reachable_ips_file.content | b64decode | trim).split('\n') }}"
      when: ip_file_stat.stat.exists

- name: Generate IPs from range and ping
  block:
    - name: Run Python script to generate IPs from range
      ansible.builtin.command:
        cmd: python3 generate_ips.py {{ ip_range_start }} {{ ip_range_end }}
        chdir: "{{ files_directory }}"
      register: result

    - name: Ping entire IP range using fping on remote machine
      shell: "fping -a -q -g {{ ip_range_start }} {{ ip_range_end }} || true"
      register: ping_result
      delegate_to: "{{ ssh_host }}"

    - name: Extract IPs which responded to ping
      set_fact:
        ping_responded_ips: "{{ ping_result.stdout_lines }}"

- name: Decide if we should scan with nmap
  block:
    - name: Compare pinged IPs with previously reachable IPs
      set_fact:
        should_scan: true
      when: ip_file_stat.stat.exists and
            ((previous_reachable_ips | difference(ping_responded_ips)) or
            (ping_responded_ips | difference(previous_reachable_ips)))

    - name: Set should_scan false if pinged IPs are the same as previously reachable IPs
      set_fact:
        should_scan: false
      when: ip_file_stat.stat.exists and 
            (previous_reachable_ips | difference(ping_responded_ips)) == [] and
            (ping_responded_ips | difference(previous_reachable_ips)) == []

    - name: Set should_scan true if pid_ip_file_path does not exist
      set_fact:
        should_scan: true
      when: not ip_file_stat.stat.exists

    - name: Scan IPs for open SSH ports if should_scan is true
      shell: >
        ssh -o "StrictHostKeyChecking=no" "{{ ssh_user }}@{{ ssh_host }}" -p"{{ ssh_port }}" "sudo nmap -p{{ ssh_default_port }} -oG - {{ ip_range_start.split('.')[0] }}.{{ ip_range_start.split('.')[1] }}.{{ ip_range_start.split('.')[2] }}.1-{{ ip_range_end.split('.')[-1] }} | awk '/open/ {print $2}'"
      register: ip_scan
      when: should_scan

    - name: Ensure the parent directory of pid_ip_file_path exists
      file:
        path: "{{ pid_ip_file_path | dirname }}"
        state: directory
        mode: '0755'
      when: should_scan

    - name: Record reachable IPs to pid_ip_file_path if should_scan is true
      copy:
        content: "{{ ip_scan.stdout }}"
        dest: "{{ pid_ip_file_path }}"
      when: should_scan

    - name: Read reachable IPs from pid_ip_file_path
      slurp:
        src: "{{ pid_ip_file_path }}"
      register: slurped_file_content

    - name: Decode the file content
      set_fact:
        reachable_ips: "{{ slurped_file_content['content'] | b64decode }}"

- name: Split the reachable_ips string into lines
  set_fact:
    ip_lines: "{{ reachable_ips.split('\n') }}"

- name: Initialize an empty list for target IPs
  set_fact:
    all_target_ips: []

- name: Extract IP from the split lines
  set_fact:
    all_target_ips: "{{ all_target_ips + [item | regex_search('\\d+\\.\\d+\\.\\d+\\.\\d+')] }}"
  loop: "{{ ip_lines }}"
  register: target_ip_result

- name: Debug output
  debug:
    msg: "The value of all_target_ips is {{ all_target_ips }}"

- name: Open SSH tunnel if reachable IPs found
  shell: >
    ssh -o "StrictHostKeyChecking=no" -o "ServerAliveInterval=300" -L "{{ base_ssh_tunnel_port + index }}:{{ item }}:{{ ssh_default_port }}" {{ ssh_user }}@{{ ssh_host }} -p{{ ssh_port }} -N &
    echo $! > "{{ pid_ip_dir_path }}/ssh_tunnel_pid_{{ base_ssh_tunnel_port + index }}"
  loop: "{{ all_target_ips }}"
  when: item is defined
  loop_control:
    index_var: index

- name: Wait for tunnels to establish
  wait_for:
    host: localhost
    port: "{{ base_ssh_tunnel_port + index }}"
    timeout: 30
  loop: "{{ all_target_ips }}"
  loop_control:
    index_var: index
