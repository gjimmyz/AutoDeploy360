- name: Include vars
  include_vars: ../vars/var_for_US2004.yaml

- name: Check if update-grub has been run
  stat:
    path: /var/lib/grub_updated.flag
  register: grub_updated

- name: Update GRUB timeout
  lineinfile:
    path: /etc/grub.d/00_header
    regexp: '^  set timeout=\${GRUB_RECORDFAIL_TIMEOUT:-(30|5)}'
    line: '  set timeout=${GRUB_RECORDFAIL_TIMEOUT:-5}'
    backrefs: yes
  register: grub_modified

- name: Create flag file
  file:
    path: /var/lib/grub_updated.flag
    state: touch
  when: grub_modified.changed
  become: yes

- name: Update GRUB
  command: update-grub
  when: grub_modified.changed
  become: yes

- name: Remove the flag file
  file:
    path: /var/lib/grub_updated.flag
    state: absent
  when: not grub_updated.stat.exists
  become: yes

- name: Check if hp directory exists
  stat:
    path: "/opt/hp"
  register: hp_dir_status

- name: Check if MegaRAID directory exists
  stat:
    path: "/opt/MegaRAID"
  register: megaRAID_dir_status

- name: Set fact for directories existence
  set_fact:
    directories_exist: hp_dir_status.stat.exists and megaRAID_dir_status.stat.exists

- block:
    - name: Copy the deb files
      copy:
        src: "{{ item.deb }}"
        dest: "/tmp/{{ item.deb }}"
      loop: "{{ debs }}"
      when: not directories_exist

    - name: Install the deb packages
      apt:
        deb: "/tmp/{{ item.deb }}"
        state: present
      loop: "{{ debs }}"
      when: not directories_exist
  when: not directories_exist

- name: Set Shanghai timezone
  timezone:
    name: Asia/Shanghai

- name: Configure sudoers file for user
  ansible.builtin.lineinfile:
    dest: /etc/sudoers
    regexp: '^{{ ssh_user }}'
    line: '{{ ssh_user }} ALL=(ALL) NOPASSWD: ALL'
    state: present
    validate: 'visudo -cf %s'

- name: Change various sysctl-settings
  sysctl:
    name: '{{ item.key }}'
    value: '{{ item.value }}'
    sysctl_set: yes
    state: present
    reload: yes
    ignoreerrors: yes
  with_dict: '{{ sysctl_config }}'

- name: Set limits
  lineinfile:
    dest: /etc/security/limits.conf
    line: "{{ item }}"
    state: present
  loop:
    - '*                soft    nofile           819200'
    - '*                hard    nofile           819200'
    - 'root             soft    nofile           819200'
    - 'root             hard    nofile           819200'
    - '*                soft    core             2048000'
    - '*                hard    core             2048000'
    - '*                soft    nproc            65535'
    - '*                hard    nproc            65535'

- name: Check if /etc/rc.local file exists
  ansible.builtin.stat:
    path: /etc/rc.local
  register: rc_local_stat

- name: Create /etc/rc.local if it doesn't exist
  ansible.builtin.file:
    path: /etc/rc.local
    state: touch
    mode: '0755'
  when: not rc_local_stat.stat.exists

- name: Ensure /etc/rc.local has correct shebang
  ansible.builtin.lineinfile:
    path: /etc/rc.local
    line: "#!/bin/sh -e"
    insertbefore: BOF
    state: present

- name: Insert command into /etc/rc.local
  ansible.builtin.blockinfile:
    path: /etc/rc.local
    block: |
      #
      # rc.local
      #
      # This script is executed at the end of each multiuser runlevel.
      # Make sure that the script will "exit 0" on success or any other
      # value on error.
      #
      # In order to enable or disable this script just change the execution
      # bits.
      #
      # By default this script does nothing.
      echo "this is test"
    insertafter: BOF
    marker: "# {mark} ANSIBLE MANAGED BLOCK"

- name: Check if lock file exists
  stat:
    path: /var/cache/apt/.update-lock
  register: lock_file_stat

- name: Check last update
  stat:
    path: /var/cache/apt/pkgcache.bin
  register: apt_cache_stat
  when: lock_file_stat.stat.exists

- name: Update apt cache if it's outdated or lock file does not exist
  command: apt-get update
  when: not lock_file_stat.stat.exists or (ansible_date_time.epoch | int - apt_cache_stat.stat.mtime | int > 3600)

- name: Create lock file
  file:
    path: /var/cache/apt/.update-lock
    state: touch
  when: not lock_file_stat.stat.exists or (ansible_date_time.epoch | int - lock_file_stat.stat.mtime | int > 3600)

- name: Install base package
  apt:
    name: "{{ software_list }}"
    state: present

- name: Get current tuned profile
  shell: "tuned-adm active | awk -F': ' '{print $2}'"
  register: current_tuned_profile
  changed_when: False

- name: "Activate network-throughput profile"
  command: tuned-adm profile network-latency
  when: current_tuned_profile.stdout != "network-latency"

- name: Set up cron job for time synchronization
  cron:
    name: "Sync time every hour"
    minute: "30"
    hour: "*"
    user: root
    job: "{{ ntp_cron_job }}"

- name: Check sleep, suspend, hibernate, and hybrid-sleep targets
  shell: "systemctl status {{ item }} | grep -q 'masked'"
  loop:
    - sleep.target
    - suspend.target
    - hibernate.target
    - hybrid-sleep.target
  register: service_status
  changed_when: false
  failed_when: service_status.rc != 0 and service_status.rc != 1

- name: Mask sleep, suspend, hibernate, and hybrid-sleep targets if needed
  block:
    - name: Mask targets
      command: "systemctl mask {{ item }}"
      loop: "{{ service_status.results | rejectattr('rc', 'eq', 0) | map(attribute='item') | list }}"
      when: inventory_hostname == "localhost"
      register: mask_targets
      changed_when: mask_targets.rc == 0
  when: service_status.results | rejectattr('rc', 'eq', 0) | list | length > 0

- name: Targets already masked
  debug:
    msg: "All targets are already masked"
  when: service_status.results | rejectattr('rc', 'eq', 0) | list | length == 0
  changed_when: false

- name: Ignore lid switch when laptop is closed
  lineinfile:
    path: /etc/systemd/logind.conf
    regexp: "^#?HandleLidSwitch="
    line: "HandleLidSwitch=ignore"
    backrefs: yes

- name: Add NFS share to /etc/exports
  lineinfile:
    path: /etc/exports
    line: "/home/{{ ssh_user }} *(rw,no_root_squash,async)"  
    state: present
    create: yes
    backup: yes
    mode: "0644"
  register: nfs_export_result
  changed_when: nfs_export_result.changed

- name: Export NFS shares
  command: exportfs -a
  when: nfs_export_result.changed

- name: Check if network configuration was applied
  stat:
    path: /var/lib/netplan_applied
  register: netplan_applied

- name: Collect networking facts
  setup:
    gather_subset: network
  when: not netplan_applied.stat.exists

- name: Reset connection
  meta: reset_connection
  when: not netplan_applied.stat.exists

- name: Rename original 00-installer-config.yaml to backup
  copy:
    remote_src: yes
    src: /etc/netplan/00-installer-config.yaml
    dest: /etc/netplan/00-installer-config.yaml.bak
  when: not netplan_applied.stat.exists

- name: Remove original 00-installer-config.yaml
  file:
    path: /etc/netplan/00-installer-config.yaml
    state: absent
  when: not netplan_applied.stat.exists

- name: Configure static IP
  template:
    src: netplan_template.j2
    dest: /etc/netplan/01-netcfg.yaml
  when: not netplan_applied.stat.exists

- name: Apply network configuration
  command: netplan apply
  when: not netplan_applied.stat.exists

- name: Create a flag file after network configuration
  file:
    path: /var/lib/netplan_applied
    state: touch
  when: not netplan_applied.stat.exists

- name: Ensure the .ssh directory exists with the right permissions
  file:
    path: /root/.ssh
    state: directory
    mode: '0700'

- name: Ensure the authorized_keys file exists
  file:
    path: /root/.ssh/authorized_keys
    state: touch

- name: Ensure the authorized_keys file permissions are 600
  file:
    path: /root/.ssh/authorized_keys
    mode: '0600'

- name: Add SSH keys to authorized_keys
  lineinfile:
    path: /root/.ssh/authorized_keys
    line: "{{ item }}"
    state: present
  with_items: "{{ ssh_keys }}"

- name: Get current kernel version
  command: uname -r
  register: uname_result
  changed_when: false

- name: Set kernel version variable
  set_fact:
    kernel_version: "{{ uname_result.stdout.split('-')[0] }}-{{ uname_result.stdout.split('-')[1] }}"

- name: Hold specified packages with extracted kernel version
  command: apt-mark hold {{ item }}
  loop:
     - "linux-image-{{ kernel_version }}-generic"
     - "linux-headers-{{ kernel_version }}-generic"
     - "linux-modules-extra-{{ kernel_version }}-generic"
  changed_when: false

- name: Set values in /etc/apt/apt.conf.d/20auto-upgrades
  lineinfile:
    path: /etc/apt/apt.conf.d/20auto-upgrades
    regexp: '^APT::Periodic::Update-Package-Lists "1";'
    line: 'APT::Periodic::Update-Package-Lists "0";'

- name: Set unattended upgrades in /etc/apt/apt.conf.d/20auto-upgrades
  lineinfile:
    path: /etc/apt/apt.conf.d/20auto-upgrades
    regexp: '^APT::Periodic::Unattended-Upgrade "1";'
    line: 'APT::Periodic::Unattended-Upgrade "0";'

- name: Set values in /etc/apt/apt.conf.d/10periodic
  lineinfile:
    path: /etc/apt/apt.conf.d/10periodic
    regexp: '^APT::Periodic::Update-Package-Lists "1";'
    line: 'APT::Periodic::Update-Package-Lists "0";'
